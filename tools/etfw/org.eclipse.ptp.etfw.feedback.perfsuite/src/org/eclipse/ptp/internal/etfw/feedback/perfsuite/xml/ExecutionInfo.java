/* $Id: ExecutionInfo.java,v 1.42 2012/01/13 20:49:17 ruiliu Exp $ */

/*******************************************************************************
 * Copyright (c) 2008-2009, 2011-2012 The Board of Trustees of
 * the University of Illinois.
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors: 
 * 	   NCSA - initial API and implementation
 *******************************************************************************/

package org.eclipse.ptp.internal.etfw.feedback.perfsuite.xml;

import java.util.Date;
import java.text.SimpleDateFormat;
import java.util.Map;
import java.util.TreeMap;
import java.util.Set;
import java.util.TreeSet;
import java.util.Locale;
// used in parsing date when default locale is not en_US

import org.xml.sax.Attributes;

/**
 * Class containing information that describes process/thread execution
 * environment as well as metrics specific to a particular measurement
 * period.
 *
 * @author Rick Kufrin
 * @author Rui Liu
 */
public class ExecutionInfo {

    private static final String DATETAG       = "date";
    private static final String HOSTTAG       = "hostname";
    private static final String DOMAINTAG     = "domainname";
    private static final String PIDTAG        = "pid";
    private static final String THREADTAG     = "thread";
    private static final String USERTAG       = "username";
    private static final String COMMANDTAG    = "command";
    private static final String COMMANDMD5ATT = "md5sum";
    private static final String ANNOTATIONTAG = "annotation";
    private static final String WALLCLOCKTAG  = "wallclock";
    private static final String WALLCLOCKUNITSATT = "units";
    private static final String CPUTIMETAG    = "cputime";
    private static final String USERTIMETAG   = "usertime";
    private static final String SYSTEMTIMETAG = "systemtime";

    private static final String WALLCLOCKUNITSTICKS   = "ticks";
    private static final String WALLCLOCKUNITSSECONDS = "seconds";

    // ctime() output: "Tue Mar  2 12:48:28 2004"
    private static final String DATEFORMAT    = "EEE MMM dd HH:mm:ss yyyy";

    private Date    date;
    private String  hostname;
    private String  domainname;
    private long    pid;
    private long    thread;
    private String  username;
    private String  command;
    private String  md5sum;
    private String  annotation;
    private long    wallticks;
    private float   wallsecs;
    private String  wallclockunits;
    private CPUTime cputime;
    private float   usertime;
    private float   systemtime;

    private String tmpValue = "";

    static private final Set<String> keySet;

    static {
	keySet = new TreeSet<String>();
	keySet.add (DATETAG);
	keySet.add (HOSTTAG);
	keySet.add (DOMAINTAG);
	keySet.add (PIDTAG);
	keySet.add (THREADTAG);
	keySet.add (USERTAG);
	keySet.add (COMMANDTAG);
	keySet.add (ANNOTATIONTAG);
	keySet.add (WALLCLOCKTAG);
	keySet.add (CPUTIMETAG);
	keySet.add (USERTIMETAG);
	keySet.add (SYSTEMTIMETAG);
    }

    ExecutionInfo () {
    }

    static boolean containsKey (String str) {
	return keySet.contains (str);
    }

    void startElement(String uri, String localName, String qName,
                      Attributes atts) {
	// parse the tags specific to this class
	if (qName.equals (COMMANDTAG)) {
	    md5sum = atts.getValue (COMMANDMD5ATT);
	} else if (qName.equals (WALLCLOCKTAG)) {
	    wallclockunits = atts.getValue (WALLCLOCKUNITSATT);
	}

	tmpValue = "";
    }

    void characters(char[] ch, int start, int length) {
	String tmpString = new String (ch, start, length);
	if (tmpString.length() != 0) {
	    if (tmpValue.length() == 0) {
		tmpValue = tmpString;
	    } else {
		tmpValue = tmpValue.concat (tmpString);
	    }
	}
    }

    void endElement(String uri, String localName, String qName) {

        tmpValue = tmpValue.trim();
	if (qName.equals (DATETAG)) {
	    // SimpleDateFormat.parse() is locale-sensitive,
	    // while currently (as of Jan 2, 2009) the date times in XML reports
	    // generated by psrun and libpshwpc are of the en_US locale only.
	    // The approach we used is: save user's default locale,
	    // use en_US to parse the date, then restore user's default locale.
	    Locale savedDefaultLocale = Locale.getDefault();
	    if (! savedDefaultLocale.equals (Locale.US)) {
		Locale.setDefault (Locale.US);
	    }
	    SimpleDateFormat df = new SimpleDateFormat(DATEFORMAT);
	    try {
		date = df.parse(tmpValue);
	    } catch (java.text.ParseException pe) {
		System.err.println
                    ("Error in parsing date in ExecutionInfo.endElement:" +
                     " date = \"" + tmpValue + "\".");
                throw new RuntimeException (pe);
	    }
	    if (! savedDefaultLocale.equals (Locale.US)) {
		Locale.setDefault (savedDefaultLocale);
	    }
	} else if (qName.equals (HOSTTAG)) {
	    hostname = tmpValue;
	} else if (qName.equals (DOMAINTAG)) {
	    domainname = tmpValue;
	} else if (qName.equals (PIDTAG)) {
	    pid = Long.parseLong (tmpValue);
	} else if (qName.equals (THREADTAG)) {
	    thread = Long.parseLong (tmpValue);
	} else if (qName.equals (USERTAG)) {
	    username = tmpValue;
	} else if (qName.equals (COMMANDTAG)) {
	    command = tmpValue;
	} else if (qName.equals (ANNOTATIONTAG)) {
	    annotation = tmpValue;
	} else if (qName.equals (WALLCLOCKTAG)) {
	    if (wallclockunits.equals (WALLCLOCKUNITSTICKS)) {
		wallticks = Long.parseLong (tmpValue);
		wallsecs = 0;
	    } else {
		// units is "seconds"
		wallticks = 0;
		wallsecs = Float.parseFloat (tmpValue);
	    }
	} else if (qName.equals (USERTIMETAG)) {
	    usertime = Float.parseFloat (tmpValue);
	} else if (qName.equals (SYSTEMTIMETAG)) {
	    systemtime = Float.parseFloat (tmpValue);
	} else if (qName.equals (CPUTIMETAG)) {
	    cputime = new CPUTime (usertime, systemtime);
	}

	tmpValue = "";
    }

    /**
     * Returns a string representation of this execution information object.
     */
    public String toString() {
        StringBuilder res = new StringBuilder();
        res.append("Execution information:\n");
        res.append("  [Date:        " + date.toString() + "]\n");
        res.append("  [Hostname:    " + hostname + "]\n");
        if (pid != 0) {
            res.append("  [PID:         " + pid + "]\n");
        }
        if (thread != 0) {
            res.append("  [Thread ID (0-based): " + thread + "]\n");
        }
        res.append("  [User:        " + username + "]\n");
        res.append("  [Command:     " + command + "]\n");
        if ( md5sum != null ) {
            res.append("  [Checksum:    " + md5sum + "]\n");
        }
        if ( annotation != null ) {
            res.append("  [Annotation:  " + annotation + "]\n");
        }
        if (cputime != null)
            res.append(cputime.toString());

        return res.toString();
    }

    /**
     * Returns a Date object corresponding to the time at which the
     * PerfSuite XML document was created (normally the end of the
     * measurement period).
     */
    public Date getDate() {
        return date;
    }

    /**
     * Returns the host name of the computer on which the measurement
     * was taken.
     */
    public String getHostName() { 
        return hostname;
    }

    /**
     * Returns the domain name of the computer on which the measurement
     * was taken.  This is typically the constant <code>null</code>.
     */
    public String getDomainName() { 
        return domainname;
    }

    /**
     * Returns the process id (PID) of the program that was measured.
     */
    public long getPid() {
        return pid;
    }

    /**
     * Returns the zero-based thread id of the thread that was measured;
     * please note that this is the id internal to the program,
     * not the OS thread id.
     */
    public long getThreadId() {
        return thread;
    }

    /**
     * Returns the login/user name associated with the measurement.
     */
    public String getUserName() {
        return username;
    }

    /**
     * Returns a string corresponding to the name of the executable
     * that was measured.
     */
    public String getCommand() { 
        return command;
    }

    /**
     * Returns a string corresponding to an MD5 checksum of the
     * executable, if present in the document.
     * Returns <code>null</code> if not.
     */
    public String getMD5Sum() {
        return md5sum;
    }

    /**
     * Returns the string that was optionally set by the user as
     * a PerfSuite &quot;annotation&quot; element at the time at
     * which the measurement was taken.
     */
    public String getAnnotation() {
        return annotation;
    }

    /**
     * Returns the total wall clock ticks (elapsed CPU cycles) between
     * the time that measurement began and ended. When wall clock units
     * is &quot;seconds&quot;, this method returns 0. So typical use is first
     * call <code>getWallTicks</code>. If return value is 0,
     * then use the value returned by <code>getWallSecs</code>;
     * otherwise use the value returned by <code>getWallTicks</code>.
     */
    public long getWallTicks() { return wallticks; }

    /**
     * Returns the total wall clock time (elapsed seconds) between
     * the time that measurement began and ended. When wall clock units
     * is &quot;ticks&quot;, this method returns 0.
     */
    public float getWallSecs() { return wallsecs; }

    /**
     * Returns the CPU time consumed by the process/thread during the
     * measurement.
     */
    public CPUTime getCPUTime() { return cputime; }

}
